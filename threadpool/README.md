# 半同步/半反应堆线程池

## 线程池和两种并发模式

相对于进程池，线程池的通用性要高的多，因为它使用一个工作队列完全解除了主线程和工作线程的耦合关系

示意图：
```
                             主线程
                |------------------------------|
                |        对监听/连接 socket     |
                |------------------------------|
                               |   (插入连接 socket)
                              \|/
     |---------------------------------------------------|
     |                      请求队列                      |
     |---------------------------------------------------|
        |                      |                        |
       \|/                    \|/                      \|/
 |---------------|    |---------------|         |---------------|
 |  从工作队列中  |    |  从工作队列中  |         |  从工作队列中  |
 | 获取连接socket |    | 获取连接socket |        | 获取连接socket | 
 |---------------|    |---------------|         |---------------|
      工作线程              工作线程                   工作线程
```

异步线程只有一个，由主线程来充当，它负责监听所有 socket 上的事件，它可以只负责将 socket 连接插入请求队列（Reactor 模式），也可以有主线程完成数据的读写（模拟 Proactor）

Reactor 模式 ：

主线程只负责监听文件描述上是否有事件发生，有的话立即将该事件通知工作线程（逻辑单元），除此之外主线程不做任何实质性工作。读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由同步I/O实现。

Proactor 模式：

将所有的 I/O 操作都交给主线程和内核处理，工作线程只负责业务逻辑，通常由异步I/O实现

由于异步 I/O 不成熟，这里采用 模拟 Proactor 模式。

## 静态变量知识点

```static``` 无论建立多少个对象，都只有一个静态成员变量，静态成员变量属于一个类，被所有对象共享。

静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区。

最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。

非静态成员类外不能初始化。


* 静态成员函数

静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。

普通成员函数可以访问普通成员变量，也可以访问静态成员变量。

静态成员函数没有this指针。静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。


## 线程池函数

```append()``` 向队列添加线程，最后需要 Post 来用信号唤醒睡眠的线程

```run()``` 从工作队列中取出某个任务并进行处理